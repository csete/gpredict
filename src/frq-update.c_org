/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*
    Gpredict: Real-time satellite tracking and orbit prediction program

    Copyright (C)  2001-2013  Alexandru Csete, OZ9AEC.
    Copyright (C)  2009 Charles Suprin AA1VS.

    Authors: Alexandru Csete <oz9aec@gmail.com>

    Frequency update from SatNogs services added by Baris DINC (TA7W) July 2016 

    Comments, questions and bugreports should be submitted via
    http://sourceforge.net/projects/gpredict/
    More details can be found at the project home page:

            http://gpredict.oz9aec.net/

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, visit http://www.fsf.org/

*/
#include <glib.h>
#include <glib/gstdio.h>
#include <glib/gi18n.h>
#include <gtk/gtk.h>
#ifdef HAVE_CONFIG_H
#  include <build-config.h>
#endif
#include <curl/curl.h>
#include "sgpsdp/sgp4sdp4.h"
#include "sat-log.h"
#include "sat-cfg.h"
#include "compat.h"
#include "frq-update.h"
#include "gpredict-utils.h"


/* private function prototypes */
static size_t  my_write_func (void *ptr, size_t size, size_t nmemb, FILE *stream);
static gint    read_fresh_frq (const gchar *dir, const gchar *fnam, GHashTable *data);
static gboolean is_frq_file (const gchar *dir, const gchar *fnam);


static void    update_frq_in_file (const gchar *ldname,
                                   const gchar *fname,
                                   GHashTable  *data,
                                   guint       *sat_upd,
                                   guint       *sat_ski,
                                   guint       *sat_nod,
                                   guint       *sat_tot);

static guint add_new_sats (GHashTable *data);
static gboolean is_computer_generated_name (gchar *satname);


/** \bief Free a new_frq_t structure. */
static void free_new_frq (gpointer data)
{
    new_frq_t *frq;

    frq = (new_frq_t *) data;

    g_free (frq->satname);
    g_free (frq->line1);
    g_free (frq->line2);
    g_free (frq->srcfile);
    g_free (frq);
}


/** \brief Update FRQ files from local files.
 *  \param dir Directory where files are located.
 *  \param filter File filter, e.g. *.txt (not used at the moment!)
 *  \param silent TRUE if function should execute without graphical status indicator.
 *  \param label1 Activity label (can be NULL)
 *  \param label2 Statistics label (can be NULL)
 *  \param progress Pointer to progress indicator.
 *  \param init_prgs Initial value of progress indicator, e.g 0.5 if we are updating
 *                   from network.
 *
 * This function is used to update the FRQ data from local files.
 *
 * Functional description: TBD
 *
 */
void frq_update_from_files (const gchar *dir, const gchar *filter,
                            gboolean silent, GtkWidget *progress,
                            GtkWidget *label1, GtkWidget *label2)
{
    static GMutex frq_file_in_progress;

    GHashTable  *data;        /* hash table with fresh FRQ data */
    GDir        *cache_dir;   /* directory to scan fresh FRQ */
    GDir        *loc_dir;     /* directory for gpredict FRQ files */
    GError      *err = NULL;
    gchar       *text;
    gchar       *ldname;
    gchar       *userconfdir;
    const gchar *fnam;
    guint        num = 0;
    guint        updated,updated_tmp;
    guint        skipped,skipped_tmp;
    guint        nodata,nodata_tmp;
    guint        newsats = 0;
    guint        total,total_tmp;
    gdouble      fraction = 0.0;
    gdouble      start = 0.0;

    (void) filter; /* avoid unused parameter compiler warning */

    if (g_mutex_trylock(&frq_file_in_progress) == FALSE)
    {
        sat_log_log (SAT_LOG_LEVEL_ERROR,
                     _("%s: A FRQ update process is already running. Aborting."),
                     __func__);

        return;
    }

    /* create hash table */
    data = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, free_new_frq);

    /* open directory and read files one by one */
    cache_dir = g_dir_open (dir, 0, &err);

    if (err != NULL) {

        /* send an error message */
        sat_log_log (SAT_LOG_LEVEL_ERROR,
                     _("%s: Error opening directory %s (%s)"),
                     __func__, dir, err->message);

        /* insert error message into the status string, too */
        if (!silent && (label1 != NULL)) {
            text = g_strdup_printf (_("<b>ERROR</b> opening directory %s\n%s"),
                                    dir, err->message);

            gtk_label_set_markup (GTK_LABEL (label1), text);
            g_free (text);

        }

        g_clear_error (&err);
        err = NULL;
    }
    else {

        /* scan directory for frq files */
        while ((fnam = g_dir_read_name (cache_dir)) != NULL) {
            /* check that we got a FRQ file */
            if (is_frq_file(dir, fnam)) {
                
                /* status message */
                if (!silent && (label1 != NULL)) {
                    text = g_strdup_printf (_("Reading data from %s"), fnam);
                    gtk_label_set_text (GTK_LABEL (label1), text);
                    g_free (text);

                    /* Force the drawing queue to be processed otherwise there will
                        not be any visual feedback, ie. frozen GUI
                        - see Gtk+ FAQ http://www.gtk.org/faq/#AEN602
                    */
                    while (g_main_context_iteration (NULL, FALSE));

                    /* give user a chance to follow progress */
                    g_usleep (G_USEC_PER_SEC / 100);
                }

                /* now, do read the fresh data */
                num = read_fresh_frq (dir, fnam, data);
            } else {
                num = 0;
            }

            if (num < 1) {
                sat_log_log (SAT_LOG_LEVEL_ERROR,
                             _("%s: No valid FRQ data found in %s"),
                             __func__, fnam);
            }
            else {
                sat_log_log (SAT_LOG_LEVEL_INFO,
                             _("%s: Read %d sats from %s into memory"),
                             __func__, num, fnam);
            }
        }

        /* close directory since we don't need it anymore */
        g_dir_close (cache_dir);

        /* now we load each .sat file and update if we have new data */
        userconfdir = get_user_conf_dir ();
        ldname = g_strconcat (userconfdir, G_DIR_SEPARATOR_S, "satdata", NULL);
        g_free (userconfdir);

        /* open directory and read files one by one */
        loc_dir = g_dir_open (ldname, 0, &err);

        if (err != NULL) {

            /* send an error message */
            sat_log_log (SAT_LOG_LEVEL_ERROR,
                         _("%s: Error opening directory %s (%s)"),
                         __func__, dir, err->message);

            /* insert error message into the status string, too */
            if (!silent && (label1 != NULL)) {
                text = g_strdup_printf (_("<b>ERROR</b> opening directory %s\n%s"),
                                        dir, err->message);

                gtk_label_set_markup (GTK_LABEL (label1), text);
                g_free (text);
            }

            g_clear_error (&err);
            err = NULL;
        }
        else {
            /* clear statistics */
            updated = 0;
            skipped = 0;
            nodata = 0;
            total = 0;

            /* get initial value of progress indicator */
            if (progress != NULL)
                start = gtk_progress_bar_get_fraction (GTK_PROGRESS_BAR (progress));

            /* This is insane but I don't know how else to count the number of sats */
            num = 0;
            while ((fnam = g_dir_read_name (loc_dir)) != NULL) {
                /* only consider .sat files */
                if (g_str_has_suffix (fnam, ".sat")) {
                    num++;
                }
            }

            g_dir_rewind (loc_dir);

            /* update FRQ files one by one */
            while ((fnam = g_dir_read_name (loc_dir)) != NULL) {
                /* only consider .sat files */
                if (g_str_has_suffix (fnam, ".sat")) {

                    /* clear stat bufs */
                    updated_tmp = 0;
                    skipped_tmp = 0;
                    nodata_tmp = 0;
                    total_tmp = 0;

                    /* update FRQ data in this file */
                    update_frq_in_file (ldname, fnam, data, &updated_tmp, &skipped_tmp, &nodata_tmp, &total_tmp);

                    /* update statistics */
                    updated += updated_tmp;
                    skipped += skipped_tmp;
                    nodata  += nodata_tmp;
                    total   = updated+skipped+nodata;

                    if (!silent) {

                        if (label1 != NULL) {
                            gtk_label_set_text (GTK_LABEL (label1),
                                                _("Updating data..."));
                        }

                        if (label2 != NULL) {
                            text = g_strdup_printf (_("Satellites updated:\t %d\n"\
                                                      "Satellites skipped:\t %d\n"\
                                                      "Missing Satellites:\t %d\n"),
                                                    updated, skipped, nodata);
                            gtk_label_set_text (GTK_LABEL (label2), text);
                            g_free (text);
                        }

                        if (progress != NULL) {
                            /* two different calculations for completeness depending on whether 
                               we are adding new satellites or not. */
                            if (sat_cfg_get_bool (SAT_CFG_BOOL_FRQ_ADD_NEW)) {
                                /* In this case we are possibly processing more than num satellites
                                   How many more? We do not know yet.  Worst case is g_hash_table_size more.
                                   
                                   As we update skipped and updated we can reduce the denominator count
                                   as those are in both pools (files and hash table). When we have processed 
                                   all the files, updated and skipped are completely correct and the progress 
                                   is correct. It may be correct sooner if the missed satellites are the 
                                   last files to process.
                                   
                                   Until then, if we eliminate the ones that are updated and skipped from being 
                                   double counted, our progress will shown will always be less or equal to our 
                                   true progress since the denominator will be larger than is correct.
                                   
                                   Advantages to this are that the progress bar does not stall close to 
                                   finished when there are a large number of new satellites.
                                */
                                fraction = start + (1.0-start) * ((gdouble) total) / 
                                    ((gdouble) num + g_hash_table_size(data) - updated - skipped);
                            } else {
                                /* here we only process satellites we have have files for so divide by num */
                                fraction = start + (1.0-start) * ((gdouble) total) / ((gdouble) num);
                            }
                            gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (progress),
                                                           fraction);

                        }

                        /* update the gui only every so often to speed up the process */
                        /* 47 was selected empirically to balance the update looking smooth but not take too much time. */
                        /* it also tumbles all digits in the numbers so that there is no obvious pattern. */
                        /* on a developer machine this improved an update from 5 minutes to under 20 seconds. */
                        if (total%47 == 0) {
                            /* Force the drawing queue to be processed otherwise there will
                               not be any visual feedback, ie. frozen GUI
                               - see Gtk+ FAQ http://www.gtk.org/faq/#AEN602
                            */
                            while (g_main_context_iteration (NULL, FALSE));
                        
                            /* give user a chance to follow progress */
                            g_usleep (G_USEC_PER_SEC / 1000);
                        }
                    }
                }
            }
            
            /* force gui update */
            while (g_main_context_iteration (NULL, FALSE));


            /* close directory handle */
            g_dir_close (loc_dir);
            
            /* see if we have any new sats that need to be added */
            if (sat_cfg_get_bool (SAT_CFG_BOOL_FRQ_ADD_NEW)) {
                
                newsats = add_new_sats (data);
                
                if (!silent && (label2 != NULL)) {
                    text = g_strdup_printf (_("Satellites updated:\t %d\n"\
                                              "Satellites skipped:\t %d\n"\
                                              "Missing Satellites:\t %d\n"\
                                              "New Satellites:\t\t %d"),
                                            updated, skipped, nodata, newsats);
                    gtk_label_set_text (GTK_LABEL (label2), text);
                    g_free (text);

                }
                
                sat_log_log (SAT_LOG_LEVEL_INFO,
                             _("%s: Added %d new satellites to local database"),
                             __func__, newsats);
            }

            /* store time of update if we have updated something */
            if ((updated > 0) || (newsats > 0)) {
                GTimeVal tval;
                
                g_get_current_time (&tval);
                sat_cfg_set_int (SAT_CFG_INT_FRQ_LAST_UPDATE, tval.tv_sec);
            }

        }

        g_free (ldname);

        sat_log_log (SAT_LOG_LEVEL_INFO,
                     _("%s: FRQ elements updated."),
                     __func__);
    }

    /* destroy hash tables */
    g_hash_table_destroy (data);

    g_mutex_unlock(&frq_file_in_progress);
}



/** \brief Check if satellite is new, if so, add it to local database */
static void check_and_add_sat (gpointer key, gpointer value, gpointer user_data)
{
    new_frq_t  *nfrq = (new_frq_t *) value;
    guint      *num = user_data;
    GKeyFile   *satdata;
    GIOChannel *satfile;
    gchar      *cfgstr, *cfgfile;
    GError     *err = NULL;

    (void) key; /* avoid unused parameter compiler warning */
    /* check if sat is new */
    if (nfrq->isnew) {

        /* create config data */
        satdata = g_key_file_new ();

        /* store data */
        g_key_file_set_string (satdata, "Satellite", "VERSION", "1.1");
        g_key_file_set_string (satdata, "Satellite", "NAME", nfrq->satname);
        g_key_file_set_string (satdata, "Satellite", "NICKNAME", nfrq->satname);
        g_key_file_set_string (satdata, "Satellite", "FRQ1", nfrq->line1);
        g_key_file_set_string (satdata, "Satellite", "FRQ2", nfrq->line2);
        g_key_file_set_integer (satdata, "Satellite", "STATUS", nfrq->status);

        /* create an I/O channel and store data */
        cfgfile = sat_file_name_from_catnum (nfrq->catnum);
        if (!gpredict_save_key_file (satdata, cfgfile)){
            *num += 1;
        }

        /* clean up memory */
        g_free (cfgfile);
        g_key_file_free (satdata);

        /**** FIXME: NEED TO CREATE COPY of cache */
        /* finally, new satellite must be added to proper category */
        gchar *catfile;
        gchar **buff;
        gint  statretval;
        struct stat temp;

        buff = g_strsplit (nfrq->srcfile, ".", 0);
        cfgfile = g_strconcat (buff[0], ".cat", NULL);
        catfile = sat_file_name (cfgfile);

        /* call stat on file before opening it incase file does 
           not exist and we need to add a group name. */
        statretval = stat (catfile,&temp);
        /* g_io_channel */
        satfile = g_io_channel_new_file (catfile, "a", &err);

        if (err != NULL) {
            sat_log_log (SAT_LOG_LEVEL_ERROR,
                         _("%s: Could not open category file file %s (%s)."),
                         __func__, cfgfile, err->message);
            g_clear_error (&err);
        }
        else {
            if (statretval == -1) {
                /* file did not exist before creating handle */
                /* use the file name as the group description */
                cfgstr = g_strdup_printf ("%s\n", buff[0]);
                g_io_channel_write_chars (satfile, cfgstr, -1, NULL, &err);
                g_free (cfgstr);

            }

            cfgstr = g_strdup_printf ("%d\n", nfrq->catnum);
            g_io_channel_write_chars (satfile, cfgstr, -1, NULL, &err);
            g_io_channel_shutdown (satfile, TRUE, NULL);
            g_io_channel_unref (satfile);
            g_free (cfgstr);

            if (err != NULL) {
                sat_log_log (SAT_LOG_LEVEL_ERROR,
                             _("%s: Error adding %d to %s (%s)."),
                             __func__, nfrq->catnum, cfgfile, err->message);
                g_clear_error (&err);
            }
            else {
                sat_log_log (SAT_LOG_LEVEL_INFO,
                             _("%s: Added satellite %d to %s."),
                             __func__, nfrq->catnum, cfgfile);
            }
        }

        g_free (catfile);
        g_free (cfgfile);
        g_strfreev (buff);
    }

}


/** \brief Add new satellites to local database */
static guint add_new_sats (GHashTable *data)
{
    guint num = 0;

    g_hash_table_foreach (data, check_and_add_sat, &num);

    return num;
}



/** \brief Update FRQ files from network.
 *  \param silent TRUE if function should execute without graphical status indicator.
 *  \param progress Pointer to a GtkProgressBar progress indicator (can be NULL)
 *  \param label1 GtkLabel for activity string.
 *  \param label2 GtkLabel for statistics string.
 */
void frq_update_from_network (gboolean   silent,
                              GtkWidget *progress,
                              GtkWidget *label1,
                              GtkWidget *label2)
{
    static GMutex frq_in_progress;

    gchar       *server;
    gchar       *proxy = NULL;
    gchar       *files_tmp;
    gchar      **files;
    guint        numfiles;
    gchar       *curfile;
    gchar       *locfile;
    gchar       *userconfdir;
    CURL        *curl;
    CURLcode     res;
    gdouble      fraction,start=0;
    FILE        *outfile;
    GDir        *dir;
    gchar       *cache;
    const gchar *fname;
    gchar       *text;
    GError      *err = NULL;
    guint        success = 0; /* no. of successfull downloads */ 

    /* bail out if we are already in an update process */
    if (g_mutex_trylock(&frq_in_progress) == FALSE)
    {
        sat_log_log (SAT_LOG_LEVEL_ERROR,
                     _("%s: A FRQ update process is already running. Aborting."),
                     __func__);

        return;
    }

    /* get server, proxy, and list of files */
    server = sat_cfg_get_str (SAT_CFG_STR_FRQ_SERVER);
    proxy  = sat_cfg_get_str (SAT_CFG_STR_FRQ_PROXY);
    files_tmp = sat_cfg_get_str (SAT_CFG_STR_FRQ_FILES);
    files = g_strsplit (files_tmp, ";", 0);
    numfiles = g_strv_length (files);

    sat_log_log (SAT_LOG_LEVEL_INFO, _("Ready to fetch satellite list from satnogs..."), __func__);


        /* initialise progress bar */
        if (!silent && (progress != NULL))
            start = gtk_progress_bar_get_fraction (GTK_PROGRESS_BAR (progress));

        /* initialise curl */
        curl = curl_easy_init();
        if (proxy != NULL)
            curl_easy_setopt (curl, CURLOPT_PROXY, proxy);

        curl_easy_setopt (curl, CURLOPT_USERAGENT, "gpredict/curl");
        curl_easy_setopt (curl, CURLOPT_CONNECTTIMEOUT, 10);

        /* get files */
        /* set URL */
        curfile = g_strconcat (server, "", NULL);
        curl_easy_setopt (curl, CURLOPT_URL, curfile);

        /* set activity message */
        if (!silent && (label1 != NULL)) {

        text = g_strdup_printf (_("Fetching %s"), "satellites.json");
        gtk_label_set_text (GTK_LABEL (label1), text);
        g_free (text);

        /* Force the drawing queue to be processed otherwise there will
           not be any visual feedback, ie. frozen GUI
           - see Gtk+ FAQ http://www.gtk.org/faq/#AEN602
        */
        while (g_main_context_iteration (NULL, FALSE));
        }

        /* create local cache file */
        userconfdir = get_user_conf_dir ();
        //locfile = g_strconcat (userconfdir, G_DIR_SEPARATOR_S, "satdata", G_DIR_SEPARATOR_S, "cache", G_DIR_SEPARATOR_S, files[i], NULL);
        locfile = g_strconcat (userconfdir, G_DIR_SEPARATOR_S, "satdata", G_DIR_SEPARATOR_S, "cache", G_DIR_SEPARATOR_S, "satellites.json", NULL);
	//baris
        locfile = g_strconcat ("/tmp/satellites.json",NULL);

        outfile = g_fopen (locfile, "wb");
        if (outfile != NULL) {
           curl_easy_setopt (curl, CURLOPT_WRITEDATA, outfile);
           curl_easy_setopt (curl, CURLOPT_WRITEFUNCTION, my_write_func);
                
           /* get file */
           res = curl_easy_perform (curl);
                
           if (res != CURLE_OK) {
              sat_log_log (SAT_LOG_LEVEL_ERROR, _("%s: Error fetching %s (%s)"), __func__, curfile, curl_easy_strerror (res));
                }
                else {
                    sat_log_log (SAT_LOG_LEVEL_INFO, _("%s: Successfully fetched %s"), __func__, curfile);
                    success++;
                }
                fclose (outfile);

            } else {
                sat_log_log (SAT_LOG_LEVEL_INFO, _("%s: Failed to open %s preventing update"), __func__, locfile);
            }
            /* update progress indicator */
            if (!silent && (progress != NULL)) {

                /* complete download corresponds to 50% */
                fraction = start + (0.5-start)  / (1.0 * numfiles);
                gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (progress), fraction);

                /* Force the drawing queue to be processed otherwise there will
                    not be any visual feedback, ie. frozen GUI
                    - see Gtk+ FAQ http://www.gtk.org/faq/#AEN602
                */
                while (g_main_context_iteration (NULL, FALSE));

            }

            g_free (userconfdir);
            g_free (curfile);
            g_free (locfile);

        curl_easy_cleanup (curl);

        /* continue update if we have fetched at least one file */
        if (success > 0) {
            sat_log_log (SAT_LOG_LEVEL_INFO, _("%s: Fetched %d files from network; updating..."), __func__, success);
            /* call update_from_files */
            cache = sat_file_name ("cache");
            frq_update_from_files (cache, NULL, silent, progress, label1, label2);
            g_free (cache);

        }
        else {
            sat_log_log (SAT_LOG_LEVEL_ERROR, _("%s: Could not fetch any new FRQ files from network; aborting..."), __func__);
        }


    /* clear cache and memory */
    g_free (server);
    g_strfreev (files);
    g_free (files_tmp);
    if (proxy != NULL)
        g_free (proxy);

    /* open cache */
    cache = sat_file_name ("cache");
    dir = g_dir_open (cache, 0, &err);

    if (err != NULL) {
        /* send an error message */
        sat_log_log (SAT_LOG_LEVEL_ERROR, _("%s: Error opening %s (%s)"), __func__, dir, err->message);
        g_clear_error (&err);
    }
    else {
        /* delete files in cache one by one */
        while ((fname = g_dir_read_name (dir)) != NULL) {
            locfile = g_strconcat (cache, G_DIR_SEPARATOR_S, fname, NULL);
            g_remove (locfile);
            g_free (locfile);
        }
        /* close cache */
        g_dir_close (dir);
    }

    g_free (cache);

    g_mutex_unlock(&frq_in_progress);

}


/** \brief Write FRQ data block to file.
 *  \param ptr Pointer to the data block to be written.
 *  \param size Size of data block.
 *  \param nmemb Size multiplier?
 *  \param stream Pointer to the file handle.
 *  \return The number of bytes actually written.
 *
 * This function writes the received data to the file pointed to by stream.
 * It is used as write callback by to curl exec function.
 */
static size_t my_write_func (void *ptr, size_t size, size_t nmemb, FILE *stream)
{
    /*** FIXME: TBC whether this works in wintendo */
    return fwrite (ptr, size, nmemb, stream);
}


/** \brief Check whether file is FRQ file.
 *  \param dir The directory.
 *  \param fnam The file name.
 * 
 * This function checks whether the file with path dir/fnam is a potential
 * FRQ file. Checks performed:
 *   - It is a real file
 *   - suffix is .txt or .frq
 */
static gboolean is_frq_file (const gchar *dir, const gchar *fnam)
{
    gchar    *path;
    gchar    *fname_lower;
    gboolean  fileIsOk = FALSE;
    
    path = g_strconcat (dir, G_DIR_SEPARATOR_S, fnam, NULL);
    fname_lower=g_ascii_strdown(fnam,-1);
    
    if (g_file_test (path, G_FILE_TEST_IS_REGULAR) && 
        (g_str_has_suffix(fname_lower, ".frq") || g_str_has_suffix(fname_lower, ".txt")))
    {
        fileIsOk = TRUE;      
    }
    g_free (fname_lower);
    g_free (path);
    
    return fileIsOk;
}


/** \brief Read fresh FRQ data into hash table.
 *  \param dir The directory to read from.
 *  \param fnam The name of the file to read from.
 *  \param fresh_data Hash table where the data should be stored.
 *  \return The number of satellites successfully read.
 * 
 * This function will read fresh FRQ data from local files into memory.
 * If there is a saetllite category (.cat file) with the same name as the
 * input file it will also update the satellites in that category.
 */
static gint read_fresh_frq (const gchar *dir, const gchar *fnam, GHashTable *data)
{
    new_frq_t *nfrq;
    tle_t      frq;
    gchar     *path;
    gchar      frq_str[3][80];
    gchar      frq_working[3][80];
    gchar      linetmp[80];
    guint      linesneeded = 3;
    gchar      catstr[6];
    gchar      idstr[7]="\0\0\0\0\0\0\0",idyearstr[3];
    gchar     *b;
    FILE      *fp;
    gint       retcode = 0;
    guint      catnr,i,idyear;
    guint     *key = NULL;

    /* category sync related */
    gchar     *catname, *catpath, *buff, **buffv;
    FILE      *catfile;
    gchar      category[80];
    gboolean   catsync = FALSE; /* whether .cat file should be synced */

    /* 
       Normal cases to check
       1. 3 line frq file as in amatuer.txt from celestrak
       2. 2 line frq file as in .... from celestrak

       corner cases to check 
       1. 3 line frq with something at the end. (nasa.all from amsat)
       2. 2 line frq with only one in the file
       3. 2 line frq file reading the last one.
    */




    path = g_strconcat (dir, G_DIR_SEPARATOR_S, fnam, NULL);

    fp = g_fopen (path, "r");

    if (fp != NULL) {

        /* Prepare .cat file for sync while we read data */
        buffv = g_strsplit (fnam, ".", 0);
        catname = g_strconcat (buffv[0], ".cat", NULL);
        g_strfreev (buffv);
        catpath = sat_file_name (catname);
        g_free (catname);

        /* read category name for catfile */
        catfile = g_fopen (catpath, "r");
        if (catfile!=NULL) {
            b = fgets (category, 80, catfile);
            if (b == NULL) {
                sat_log_log (SAT_LOG_LEVEL_ERROR,
                             _("%s:%s: There is no category in %s"),
                             __FILE__, __func__, catpath);                
            }
            fclose (catfile);
            catsync = TRUE;
        }
        else {
            /* There is no category with this name (could be update from custom file) */
            sat_log_log (SAT_LOG_LEVEL_INFO,
                         _("%s:%s: There is no category called %s"),
                         __FILE__, __func__, fnam);
        }

        /* reopen a new catfile and write category name */
        if (catsync) {
            catfile = g_fopen (catpath, "w");
            if (catfile != NULL) {
                fputs (category, catfile);
            }
            else {
                catsync = FALSE;
                sat_log_log (SAT_LOG_LEVEL_ERROR,
                             _("%s:%s: Could not reopen .cat file while reading FRQ from %s"),
                             __FILE__, __func__, fnam);
            }
            
            /* .cat file now contains the category name;
               satellite catnums will be added during update in the while loop */
        }
        
        /* set b to non-null as a flag */
        b = path;

        /* read lines from frq file */
        while (fgets (linetmp, 80, fp)) {
            /*read in the number of lines needed to potentially get to a new frq*/
            switch (linesneeded) {
            case 3:
                strncpy(frq_working[0],linetmp,80);
                /* b is being used a flag here
                   if b==NULL then we only have one line read in 
                   and there is no way we have a full frq as there 
                   is only one line in the buffer.
                   A FRQ must be two or three lines.
                */
                b = fgets (frq_working[1], 80, fp);
                if (b==NULL) {
                    /* make sure there is no junk in frq_working[1] */
                    frq_working[1][0]='\0';
                    break;
                }
                /* make sure there is no junk in frq_working[2] */
                if (fgets (frq_working[2], 80, fp)==NULL) {
                    frq_working[2][0]='\0';
                }
                
                break;
            case 2:
                strncpy(frq_working[0],frq_working[2],80);
                strncpy(frq_working[1],linetmp,80);
                /* make sure there is no junk in frq_working[2] */
                if (fgets (frq_working[2], 80, fp)==NULL) {
                    frq_working[2][0]='\0';
                }
                break;
            case 1:
                strncpy(frq_working[0],frq_working[1],80);
                strncpy(frq_working[1],frq_working[2],80);
                strncpy(frq_working[2],linetmp,80);
                break;
            default:
                sat_log_log (SAT_LOG_LEVEL_ERROR,
                             _("%s:%s: Something wrote linesneeded to an illegal value %d"),
                             __FILE__, __func__, linesneeded);
                break;
            }
            /* b can only be null if there is only one line in the buffer*/
            /* a frq must be two or three */
            if (b == NULL) {
                break;
            }
            /* remove leading and trailing whitespace to be more forgiving */
            g_strstrip(frq_working[0]);
            g_strstrip(frq_working[1]);
            g_strstrip(frq_working[2]);
            
            /* there are three possibilities at this point */
            /* first is that line 0 is a name and normal text for three line element and that lines 1 and 2 
               are the corresponding frq */
            /* second is that line 0 and line 1 are a frq for a bare frq */
            /* third is that neither of these is true and we are consuming either text at the top of the 
               file or a text file that happens to be in the update directory 
            */ 
            if ((frq_working[1][0] == '1') && 
                (frq_working[2][0] == '2') && 
                Checksum_Good(frq_working[1]) &&
                Checksum_Good(frq_working[2])) {
                sat_log_log (SAT_LOG_LEVEL_DEBUG,
                             _("%s:%s: Processing a three line FRQ"),
                             __FILE__, __func__);
                                
                /* it appears that the first line may be a name followed by a frq */
                strncpy(frq_str[0],frq_working[0],80);
                strncpy(frq_str[1],frq_working[1],80);
                strncpy(frq_str[2],frq_working[2],80);
                /* we consumed three lines so we need three lines */
                linesneeded = 3;
                
            } else if ((frq_working[0][0] == '1') && 
                       (frq_working[1][0] == '2') &&
                       Checksum_Good(frq_working[0]) && 
                       Checksum_Good(frq_working[1])) {
                sat_log_log (SAT_LOG_LEVEL_DEBUG,
                             _("%s:%s: Processing a bare two line FRQ"),
                             __FILE__, __func__);
                
                /* first line appears to belong to the start of bare FRQ */
                /* put in a dummy name of form yyyy-nnaa base on international id */
                /* this special form will be overwritten if a three line frq ever has another name */
                
                strncpy(idstr,&frq_working[0][11],6);
                g_strstrip(idstr);
                strncpy(idyearstr,&frq_working[0][9],2);
                idstr[6]= '\0';
                idyearstr[2]= '\0';
                idyear = g_ascii_strtod(idyearstr,NULL);
                
                /* there is a two digit year field that started around sputnik */
                if (idyear >= 57)
                    idyear += 1900;
                else
                    idyear += 2000;

                snprintf(frq_str[0],79,"%d-%s",idyear,idstr);
                strncpy(frq_str[1],frq_working[0],80);
                strncpy(frq_str[2],frq_working[1],80);        
        
                /* we consumed two lines so we need two lines */
                linesneeded = 2;
            } else {
                /* we appear to have junk 
                   read another line in and do nothing else */
                linesneeded = 1;
                /* skip back to beginning of loop */
                continue;
            }


            frq_str[1][69] = '\0';
            frq_str[2][69] = '\0';

            /* copy catnum and convert to integer */
            for (i = 2; i < 7; i++) {
                catstr[i-2] = frq_str[1][i];
            }
            catstr[5] = '\0';
            catnr = (guint) g_ascii_strtod (catstr, NULL);


            if (Get_Next_Tle_Set (frq_str, &frq) != 1) {
                /* FRQ data not good */
                sat_log_log (SAT_LOG_LEVEL_ERROR,
                             _("%s:%s: Invalid data for %d"),
                             __FILE__, __func__, catnr);
            }
            else {

                if (catsync) {
                    /* store catalog number in catfile */
                    buff = g_strdup_printf ("%d\n", catnr);
                    fputs (buff, catfile);
                    g_free (buff);
                }

                /* add data to hash table */
                key = g_try_new0 (guint, 1);
                *key = catnr;
                
                nfrq = g_hash_table_lookup (data, key);
                
                /* check if satellite already in hash table */
                if ( nfrq == NULL) {

                    /* create new_frq structure */
                    nfrq = g_try_new (new_frq_t, 1);
                    nfrq->catnum = catnr;
                    nfrq->epoch = frq.epoch;
                    nfrq->status = frq.status;
                    nfrq->satname = g_strdup (frq.sat_name);
                    nfrq->line1   = g_strdup (frq_str[1]);
                    nfrq->line2   = g_strdup (frq_str[2]);
                    nfrq->srcfile = g_strdup (fnam);
                    nfrq->isnew   = TRUE; /* flag will be reset when using data */

                    g_hash_table_insert (data, key, nfrq);
                    retcode++;
                }
                else {
                    /* satellite is already in hash */
                    /* apply various merge routines */
                    
                    /* time merge */
                    if (nfrq->epoch == frq.epoch) {
                        /* if satellite epoch has the same time,  merge status as appropriate */
                        if (nfrq->status != frq.status) {
                            /* log if there is something funny about the data coming in */
                            sat_log_log (SAT_LOG_LEVEL_WARN,
                                         _("%s:%s: Two different statuses for %d (%s) at the same time."),
                                         __FILE__, __func__, nfrq->catnum, nfrq->satname);
                            if ( frq.status != OP_STAT_UNKNOWN )
                                nfrq->status = frq.status;
                        }
                    } 
                    else if ( nfrq->epoch < frq.epoch ) {
                        /* if the satellite in the hash is older than 
                           the one just loaded, copy the values over. */

                        nfrq->catnum = catnr;
                        nfrq->epoch = frq.epoch;
                        nfrq->status = frq.status;
                        g_free (nfrq->line1);
                        nfrq->line1   = g_strdup (frq_str[1]);
                        g_free (nfrq->line2);
                        nfrq->line2   = g_strdup (frq_str[2]);
                        g_free (nfrq->srcfile);
                        nfrq->srcfile = g_strdup (fnam);
                        nfrq->isnew   = TRUE; /* flag will be reset when using data */
                    }
                    
                    /* merge based on name */
                    if (is_computer_generated_name (nfrq->satname) && 
                        !is_computer_generated_name(frq_str[0])) {
                        g_free (nfrq->satname);
                        nfrq->satname = g_strdup (frq.sat_name);
                    }
                    
                    /* free the key since we do not commit it to the cache */
                    g_free (key);
                    

                }
            }

        }

        if (catsync) {
            /* close category file */
            fclose (catfile);
        }

        g_free (catpath);

        /* close input FRQ file */
        fclose (fp);

    }

    else {
        sat_log_log (SAT_LOG_LEVEL_ERROR,
                     _("%s:%s: Failed to open %s"),
                     __FILE__, __func__, path);
    }

    g_free (path);


    return retcode;
}



/** \brief Update FRQ data in a file.
 *  \param ldname Directory name for gpredict frq files.
 *  \param fname The name of the FRQ file.
 *  \param data The hash table containing the fresh data.
 *  \param sat_upd OUT: number of sats updated.
 *  \param sat_ski OUT: number of sats skipped.
 *  \param sat_nod OUT: number of sats for which no data found
 *  \param sat_tot OUT: total number of sats
 *
 * For each satellite in the FRQ file ldname/fnam, this function
 * checks whether there is any newer data available in the hash table.
 * If yes, the function writes the fresh data to temp_file, if no, the
 * old data is copied to temp_file.
 * When all sats have been copied ldname/fnam is deleted and temp_file
 * is renamed to ldname/fnam.
 */
static void update_frq_in_file (const gchar *ldname,
                                const gchar *fname,
                                GHashTable  *data,
                                guint       *sat_upd,
                                guint       *sat_ski,
                                guint       *sat_nod,
                                guint       *sat_tot)
{
    gchar     *path;
    guint      updated = 0;  /* number of updated sats */
    guint      nodata  = 0;  /* no sats for which no fresh data available */
    guint      skipped = 0;  /* no. sats where fresh data is older */
    guint      total   = 0;  /* total no. of sats in gpredict frq file */
    gchar    **catstr;
    guint      catnr;
    guint     *key = NULL;
    tle_t      frq;
    new_frq_t *nfrq;
    op_stat_t  status;
    GError    *error = NULL;
    GKeyFile  *satdata;
    gchar     *frqstr1, *frqstr2, *rawfrq, *satname, *satnickname;
    gboolean   updateddata;
    
    /* get catalog number for this satellite */
    catstr = g_strsplit (fname, ".sat", 0);
    catnr = (guint) g_ascii_strtod (catstr[0], NULL);
    

    /* see if we have new data for this satellite */
    key = g_try_new0 (guint, 1);
    *key = catnr;
    nfrq = (new_frq_t *) g_hash_table_lookup (data, key);
    g_free (key);

    if (nfrq == NULL) {
        /* no new data found for this sat => obsolete */
        nodata++;
        
        /* check if obsolete sats should be deleted */
        /**** FIXME: This is dangereous, so we omit it */
        sat_log_log (SAT_LOG_LEVEL_INFO,
                     _("%s: No new FRQ data found for %d. Satellite might be obsolete."),
                     __func__, catnr);
    }
    else { 
        /* open input file (file containing old frq) */
        path = g_strconcat (ldname, G_DIR_SEPARATOR_S, fname, NULL);
        satdata = g_key_file_new ();
        if (!g_key_file_load_from_file (satdata, path, G_KEY_FILE_KEEP_COMMENTS, &error)) {
            sat_log_log (SAT_LOG_LEVEL_ERROR,
                         _("%s: Error loading %s (%s)"),
                         __func__, path, error->message);
            g_clear_error (&error);
            
            skipped++;
            
        } else {
            
            /* This satellite is not new */
            nfrq->isnew = FALSE;

            /* get FRQ data */
            frqstr1 = g_key_file_get_string (satdata, "Satellite", "FRQ1", NULL);
            if (error != NULL) {
                sat_log_log (SAT_LOG_LEVEL_ERROR,
                             _("%s: Error reading FRQ line 2 from %s (%s)"),
                             __func__, path, error->message);
                g_clear_error (&error);
            }
            frqstr2 = g_key_file_get_string (satdata, "Satellite", "FRQ2", NULL);
            if (error != NULL) {
                sat_log_log (SAT_LOG_LEVEL_ERROR,
                             _("%s: Error reading FRQ line 2 from %s (%s)"),
                             __func__, path, error->message);
                g_clear_error (&error);
            }
            
            /* get name data */
            satname = g_key_file_get_string (satdata, "Satellite", "NAME", NULL);
            satnickname = g_key_file_get_string (satdata, "Satellite", "NICKNAME", NULL);

            /* get status data */
            if (g_key_file_has_key(satdata,"Satellite","STATUS", NULL)) {
                status = g_key_file_get_integer (satdata, "Satellite", "STATUS", NULL);
            }
            else {
                status = OP_STAT_UNKNOWN;
            }
            
            rawfrq = g_strconcat (frqstr1, frqstr2, NULL);

            if (!Good_Elements (rawfrq)) {
                sat_log_log (SAT_LOG_LEVEL_WARN,
                             _("%s: Current FRQ data for %d appears to be bad"),
                             __func__, catnr);
                /* set epoch to zero so it gets overwritten */
                frq.epoch = 0;
            } else {
                Convert_Satellite_Data (rawfrq, &frq);
            }
            g_free (frqstr1);
            g_free (frqstr2);
            g_free (rawfrq);
            
            /* Initialize flag for update */
            updateddata = FALSE;

            if (nfrq->satname != NULL) {
                /* when a satellite first appears in the elements it is sometimes refered to by the 
                   international designator which is awkward after it is given a name */
                if (!is_computer_generated_name(nfrq->satname)) {
                    
                    if (is_computer_generated_name (satname)) {
                        sat_log_log (SAT_LOG_LEVEL_INFO,
                                     _("%s: Data for  %d updated for name."),
                                     __func__, catnr);
                        g_key_file_set_string (satdata, "Satellite", "NAME", nfrq->satname);
                        updateddata = TRUE;
                    }
                    
                    /* FIXME what to do about nickname Possibilities: */
                    /* clobber with name */
                    /* clobber if nickname and name were same before */ 
                    /* clobber if international designator */
                    if ( is_computer_generated_name (satnickname) ) {
                        sat_log_log (SAT_LOG_LEVEL_INFO,
                                     _("%s: Data for  %d updated for nickname."),
                                     __func__, catnr);
                        g_key_file_set_string (satdata, "Satellite", "NICKNAME", nfrq->satname);
                        updateddata = TRUE;
                    }
                }
            }

            g_free(satname);
            g_free(satnickname);

            if (frq.epoch < nfrq->epoch) {
                /* new data is newer than what we already have */
                /* store new data */
                sat_log_log (SAT_LOG_LEVEL_INFO,
                             _("%s: Data for  %d updated for frq."),
                             __func__, catnr);
                g_key_file_set_string (satdata, "Satellite", "FRQ1", nfrq->line1);
                g_key_file_set_string (satdata, "Satellite", "FRQ2", nfrq->line2);
                g_key_file_set_integer (satdata, "Satellite", "STATUS", nfrq->status);
                updateddata = TRUE;

            } else if (frq.epoch == nfrq->epoch) {
                if  ((status != nfrq->status) && (nfrq->status != OP_STAT_UNKNOWN)){
                    sat_log_log (SAT_LOG_LEVEL_INFO,
                                 _("%s: Data for  %d updated for operational status."),
                                 __func__, catnr);
                    g_key_file_set_integer (satdata, "Satellite", "STATUS", nfrq->status);
                    updateddata = TRUE;
                }
            }
            
            if (updateddata ==TRUE) {
                if (gpredict_save_key_file(satdata, path)) {
                    skipped++;
                } else {
                    updated++;
                }
                
            }
            else {
                skipped++;
            }
        }
     
        g_key_file_free (satdata);
        g_free (path);
        
    }
    g_strfreev (catstr);

    /* update out parameters */
    *sat_upd = updated;
    *sat_ski = skipped;
    *sat_nod = nodata;
    *sat_tot = total;

}


const gchar *freq_to_str2[FRQ_AUTO_UPDATE_NUM] = {
    N_("Never"),
    N_("Monthly"),
    N_("Weekly"),
    N_("Daily")
};

const gchar *
        frq_update_freq_to_str2 (frq_auto_upd_freq_t freq)
{
    if ((freq <= FRQ_AUTO_UPDATE_NEVER) ||
        (freq >= FRQ_AUTO_UPDATE_NUM)) {

        freq = FRQ_AUTO_UPDATE_NEVER;

    }

    return _(freq_to_str2[freq]);
}

/** \brief Determine if name is generic.
 *  \param satname The satellite name that might be old.
 *
 * This function determines if the satellite name is generic. Examples of this are the names YYYY-NNNAAA 
 * international ID names used by Celestrak. Also space-track.org will give items names of OBJECT A as 
 * well until the name is advertised.  
 *
 */
static gboolean is_computer_generated_name (gchar *satname) {
    /* celestrak generic satellite name */
    if (g_regex_match_simple ("\\d{4,}-\\d{3,}",satname,0,0)){
        return (TRUE);
    }
    /* space-track generic satellite name */
    if (g_regex_match_simple ("OBJECT",satname,0,0)){
        return (TRUE);
    }
    return (FALSE);
}
